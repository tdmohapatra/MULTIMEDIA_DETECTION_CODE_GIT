@* @{
    Layout = null;
} *@

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Compact Image to Text Converter</title>
    <style>
        :root {
            --primary: #4361ee;
            --primary-dark: #3a56d4;
            --success: #4cc9f0;
            --danger: #f72585;
            --warning: #f8961e;
            --light: #f8f9fa;
            --dark: #212529;
            --gray: #6c757d;
            --border: #dee2e6;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }

        body {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
            color: var(--dark);
        }

        .compact-app {
            max-width: 1200px;
            margin: 0 auto;
            background: white;
            border-radius: 12px;
            box-shadow: 0 8px 30px rgba(0, 0, 0, 0.12);
            overflow: hidden;
        }

        .app-header {
            background: linear-gradient(135deg, var(--primary), var(--primary-dark));
            color: white;
            padding: 20px;
            text-align: center;
        }

        .app-title {
            font-size: 1.8rem;
            font-weight: 700;
            margin-bottom: 5px;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 10px;
        }

        .app-subtitle {
            font-size: 0.9rem;
            opacity: 0.9;
        }

        .app-content {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            padding: 20px;
        }

        @@media (max-width: 900px) {
            .app-content

        {
            grid-template-columns: 1fr;
        }

        }

        .section {
            background: var(--light);
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 15px;
        }

        .section-title {
            font-size: 1.1rem;
            font-weight: 600;
            margin-bottom: 15px;
            color: var(--primary);
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .btn {
            padding: 10px 15px;
            border: none;
            border-radius: 6px;
            font-size: 0.9rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            gap: 6px;
        }

        .btn-sm {
            padding: 8px 12px;
            font-size: 0.85rem;
        }

        .btn-primary {
            background: var(--primary);
            color: white;
        }

            .btn-primary:hover {
                background: var(--primary-dark);
            }

        .btn-success {
            background: var(--success);
            color: white;
        }

        .btn-warning {
            background: var(--warning);
            color: white;
        }

        .btn-danger {
            background: var(--danger);
            color: white;
        }

        .btn:disabled {
            opacity: 0.6;
            cursor: not-allowed;
        }

        .btn-group {
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
            margin-top: 10px;
        }

        .compact-controls {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
            margin-top: 10px;
        }

        .control-group {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }

        .control-label {
            font-weight: 600;
            font-size: 0.85rem;
            display: flex;
            justify-content: space-between;
        }

        .control-value {
            font-weight: normal;
            color: var(--primary);
        }

        .control-input {
            padding: 8px;
            border: 1px solid var(--border);
            border-radius: 6px;
            width: 100%;
            font-size: 0.9rem;
        }

        input[type="range"] {
            width: 100%;
        }

        .camera-container {
            position: relative;
            background: black;
            border-radius: 8px;
            overflow: hidden;
            margin-bottom: 10px;
            aspect-ratio: 16/9;
        }

        video, canvas, .captured-image {
            width: 100%;
            height: 100%;
            border-radius: 8px;
            object-fit: cover;
        }

        .mode-toggle {
            display: flex;
            background: #e9ecef;
            border-radius: 6px;
            padding: 3px;
            margin-bottom: 10px;
        }

        .mode-btn {
            flex: 1;
            padding: 8px;
            text-align: center;
            background: transparent;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-weight: 600;
            font-size: 0.85rem;
            transition: all 0.3s ease;
        }

            .mode-btn.active {
                background: var(--primary);
                color: white;
            }

        .text-area {
            width: 100%;
            height: 200px;
            padding: 15px;
            border: 1px solid var(--border);
            border-radius: 8px;
            resize: vertical;
            font-size: 0.9rem;
            line-height: 1.5;
            font-family: 'Courier New', monospace;
        }

        .text-stats {
            display: flex;
            justify-content: space-between;
            margin-top: 8px;
            font-size: 0.8rem;
            color: var(--gray);
        }

        .processing {
            text-align: center;
            padding: 15px;
            display: none;
        }

        .spinner {
            border: 3px solid #f3f3f3;
            border-top: 3px solid var(--primary);
            border-radius: 50%;
            width: 30px;
            height: 30px;
            animation: spin 1s linear infinite;
            margin: 0 auto 8px;
        }

        @@keyframes spin {
            0%

        {
            transform: rotate(0deg);
        }

        100% {
            transform: rotate(360deg);
        }

        }

        .confidence-meter {
            background: #e9ecef;
            border-radius: 10px;
            height: 8px;
            margin: 8px 0;
            overflow: hidden;
        }

        .confidence-fill {
            height: 100%;
            background: linear-gradient(90deg, var(--danger), var(--warning), var(--success));
            transition: width 0.5s ease;
        }

        .file-info {
            background: white;
            border-radius: 8px;
            padding: 10px;
            margin-top: 10px;
            border-left: 3px solid var(--primary);
            font-size: 0.85rem;
        }

        .notification {
            position: fixed;
            top: 20px;
            right: 20px;
            padding: 12px 16px;
            border-radius: 8px;
            color: white;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
            z-index: 1000;
            display: none;
            max-width: 300px;
            font-size: 0.9rem;
        }

            .notification.success {
                background: var(--success);
            }

            .notification.error {
                background: var(--danger);
            }

            .notification.warning {
                background: var(--warning);
            }

        .image-preview-container {
            position: relative;
            margin-top: 10px;
            display: none;
        }

        .image-preview {
            width: 100%;
            max-height: 150px;
            border-radius: 6px;
            object-fit: contain;
            background: #f8f9fa;
        }

        .tabs {
            display: flex;
            border-bottom: 1px solid var(--border);
            margin-bottom: 15px;
        }

        .tab {
            padding: 10px 15px;
            cursor: pointer;
            font-weight: 600;
            font-size: 0.9rem;
            border-bottom: 2px solid transparent;
            transition: all 0.3s ease;
        }

            .tab.active {
                border-bottom-color: var(--primary);
                color: var(--primary);
            }

        .tab-content {
            display: none;
        }

            .tab-content.active {
                display: block;
            }

        .capture-history {
            margin-top: 10px;
            max-height: 150px;
            overflow-y: auto;
            border: 1px solid var(--border);
            border-radius: 6px;
            padding: 8px;
            background: white;
        }

        .history-item {
            padding: 6px 8px;
            border-bottom: 1px solid var(--border);
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 0.85rem;
        }

            .history-item:last-child {
                border-bottom: none;
            }

        .history-text-preview {
            max-width: 60%;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .history-actions {
            display: flex;
            gap: 5px;
        }

        .history-action-btn {
            background: transparent;
            border: none;
            cursor: pointer;
            color: var(--primary);
            font-size: 0.9rem;
        }

        .compact-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
        }

        .language-select {
            width: 100%;
            padding: 8px;
            border: 1px solid var(--border);
            border-radius: 6px;
            font-size: 0.9rem;
        }

        .analysis-results {
            background: white;
            border-radius: 6px;
            padding: 10px;
            margin-top: 10px;
            border-left: 3px solid var(--primary);
            font-size: 0.85rem;
            display: none;
        }

        .icon-btn {
            padding: 6px 10px;
            border: none;
            border-radius: 4px;
            background: transparent;
            cursor: pointer;
            color: var(--primary);
            font-size: 0.9rem;
            display: flex;
            align-items: center;
            gap: 4px;
        }

            .icon-btn:hover {
                background: rgba(67, 97, 238, 0.1);
            }

        .compact-row {
            display: flex;
            gap: 10px;
            margin-bottom: 10px;
        }

        .compact-col {
            flex: 1;
        }
    </style>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
</head>
<body>
    <div class="compact-app">
        <div class="app-header">
            <h1 class="app-title"><i class="fas fa-camera"></i> Image to Text Converter</h1>
            <p class="app-subtitle">Extract text from images with AI-powered OCR</p>
        </div>

        <div class="app-content">
            <!-- Left Column: Input & Controls -->
            <div class="input-section">
                <div class="section">
                    <h2 class="section-title"><i class="fas fa-camera"></i> Camera Capture</h2>

                    <div class="mode-toggle">
                        <button class="mode-btn active" data-mode="manual">Manual</button>
                        <button class="mode-btn" data-mode="auto">Auto</button>
                    </div>

                    <div class="camera-container">
                        <video id="video" autoplay playsinline></video>
                        <canvas id="canvas" style="display: none;"></canvas>
                        <img id="capturedImage" class="captured-image" style="display: none;" alt="Captured image">
                    </div>

                    <div class="btn-group">
                        <button id="toggleCamera" class="btn btn-primary btn-sm">
                            <i class="fas fa-play"></i> Start Camera
                        </button>
                        <button id="captureBtn" class="btn btn-success btn-sm" disabled>
                            <i class="fas fa-camera"></i> Capture
                        </button>
                        <button id="discardBtn" class="btn btn-danger btn-sm" disabled>
                            <i class="fas fa-trash"></i> Discard
                        </button>
                    </div>

                    <div class="auto-controls" id="autoControls" style="display: none; margin-top: 10px;">
                        <div class="control-group">
                            <label class="control-label">
                                Interval <span class="control-value" id="intervalValue">5s</span>
                            </label>
                            <input type="range" id="captureInterval" class="control-input" min="1" max="60" value="5">
                        </div>

                        <div class="btn-group">
                            <button id="startAutoCapture" class="btn btn-primary btn-sm" disabled>
                                <i class="fas fa-play-circle"></i> Start Auto
                            </button>
                            <button id="stopAutoCapture" class="btn btn-danger btn-sm" disabled>
                                <i class="fas fa-stop-circle"></i> Stop
                            </button>
                        </div>

                        <div class="text-stats">
                            <span>Captures: <span id="captureCount">0</span></span>
                            <span>Text Found: <span id="textFoundCount">0</span></span>
                        </div>
                    </div>

                    <div class="processing" id="cameraProcessing">
                        <div class="spinner"></div>
                        <p>Processing image...</p>
                    </div>

                    <div class="image-preview-container" id="imagePreviewContainer">
                        <h3 class="section-title"><i class="fas fa-image"></i> Preview</h3>
                        <img id="imagePreview" class="image-preview" alt="Preview">
                    </div>
                </div>

                <div class="section">
                    <h2 class="section-title"><i class="fas fa-file-upload"></i> File Upload</h2>

                    <div class="compact-grid">
                        <button id="uploadButton" class="btn btn-primary">
                            <i class="fas fa-upload"></i> Upload
                        </button>
                        <button id="bulkUpload" class="btn btn-primary">
                            <i class="fas fa-folder-open"></i> Bulk
                        </button>
                        <button id="enhancedProcessing" class="btn btn-warning">
                            <i class="fas fa-magic"></i> Enhanced
                        </button>
                        <button id="extractWithLanguage" class="btn btn-primary">
                            <i class="fas fa-language"></i> Language
                        </button>
                    </div>

                    <div class="processing" id="uploadProcessing">
                        <div class="spinner"></div>
                        <p>Processing...</p>
                    </div>

                    <div class="file-info" id="fileInfo" style="display: none;">
                        <strong>File:</strong> <span id="fileDetails"></span>
                    </div>

                    <div class="control-group" style="margin-top: 10px;">
                        <label class="control-label">Language</label>
                        <select id="languageSelect" class="language-select">
                            <option value="eng">English</option>
                            <option value="fra">French</option>
                            <option value="deu">German</option>
                            <option value="spa">Spanish</option>
                        </select>
                    </div>
                </div>

                <div class="section">
                    <h2 class="section-title"><i class="fas fa-sliders-h"></i> Enhancement</h2>

                    <div class="compact-controls">
                        <div class="control-group">
                            <label class="control-label">Brightness</label>
                            <input type="range" id="brightness" class="control-input" min="0" max="100" value="50">
                        </div>
                        <div class="control-group">
                            <label class="control-label">Contrast</label>
                            <input type="range" id="contrast" class="control-input" min="0" max="100" value="50">
                        </div>
                    </div>

                    <div class="btn-group">
                        <button id="checkReadability" class="btn btn-primary btn-sm">
                            <i class="fas fa-search"></i> Check Readability
                        </button>
                        <button id="processBlurred" class="btn btn-primary btn-sm">
                            <i class="fas fa-eye-slash"></i> Process Blurred
                        </button>
                        <button id="processCompare" class="btn btn-primary btn-sm">
                            <i class="fas fa-code-compare"></i> Compare Methods
                        </button>
                    </div>

                    <div class="analysis-results" id="analysisResults">
                        <!-- Analysis results will appear here -->
                    </div>
                </div>
            </div>

            <!-- Right Column: Output & Results -->
            <div class="output-section">
                <div class="tabs">
                    <div class="tab active" data-tab="extracted">Text</div>
                    <div class="tab" data-tab="history">History</div>
                    <div class="tab" data-tab="export">Export</div>
                </div>

                <div class="tab-content active" id="extractedTab">
                    <div class="section">
                        <h2 class="section-title"><i class="fas fa-file-alt"></i> Extracted Text</h2>
                        <textarea id="extractedText" class="text-area" placeholder="Extracted text will appear here..."></textarea>
                        <div class="text-stats">
                            <span id="charCount">0 chars</span>
                            <span id="wordCount">0 words</span>
                            <span id="lineCount">0 lines</span>
                        </div>
                        <div class="btn-group">
                            <button id="clearText" class="btn btn-danger btn-sm">
                                <i class="fas fa-trash"></i> Clear
                            </button>
                            <button id="copyText" class="btn btn-primary btn-sm">
                                <i class="fas fa-copy"></i> Copy
                            </button>
                        </div>
                    </div>
                </div>

                <div class="tab-content" id="historyTab">
                    <div class="section">
                        <h2 class="section-title"><i class="fas fa-history"></i> History</h2>
                        <div class="capture-history" id="captureHistory">
                            <!-- History items will be added here dynamically -->
                        </div>
                        <div class="btn-group">
                            <button id="clearHistory" class="btn btn-danger btn-sm">
                                <i class="fas fa-trash"></i> Clear History
                            </button>
                        </div>
                    </div>
                </div>

                <div class="tab-content" id="exportTab">
                    <div class="section">
                        <h2 class="section-title"><i class="fas fa-download"></i> Export Options</h2>
                        <div class="compact-grid">
                            <button id="saveTxt" class="btn btn-primary">
                                <i class="fas fa-file-text"></i> TXT
                            </button>
                            <button id="saveWord" class="btn btn-primary">
                                <i class="fas fa-file-word"></i> DOCX
                            </button>
                            <button id="savePdf" class="btn btn-primary">
                                <i class="fas fa-file-pdf"></i> PDF
                            </button>
                        </div>
                    </div>

                    <div class="section">
                        <h2 class="section-title"><i class="fas fa-chart-bar"></i> OCR Results</h2>
                        <div class="file-info">
                            <strong>Confidence:</strong>
                            <div class="confidence-meter">
                                <div class="confidence-fill" id="confidenceFill" style="width: 0%"></div>
                            </div>
                            <div id="confidenceText">Not processed</div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <div id="notification" class="notification"></div>

    <script>
        // Global variables
        let mediaStream = null;
        let isCameraActive = false;
        let isAutoMode = false;
        let autoCaptureInterval = null;
        let captureCount = 0;
        let textFoundCount = 0;
        let captureHistory = [];
        let currentImagePath = null;

        // DOM elements
        const video = document.getElementById('video');
        const canvas = document.getElementById('canvas');
        const capturedImage = document.getElementById('capturedImage');
        const extractedTextArea = document.getElementById('extractedText');
        const toggleCameraBtn = document.getElementById('toggleCamera');
        const captureBtn = document.getElementById('captureBtn');
        const discardBtn = document.getElementById('discardBtn');
        const imagePreview = document.getElementById('imagePreview');
        const imagePreviewContainer = document.getElementById('imagePreviewContainer');
        const captureHistoryContainer = document.getElementById('captureHistory');

        // Initialize when page loads
        document.addEventListener('DOMContentLoaded', function() {
            initializeApp();
        });

        function initializeApp() {
            setupEventListeners();
            updateTextStats();
            loadCaptureHistory();
        }

        function setupEventListeners() {
            // Camera controls
            toggleCameraBtn.addEventListener('click', toggleCamera);
            captureBtn.addEventListener('click', captureAndProcess);
            discardBtn.addEventListener('click', discardImage);

            // Mode toggles
            document.querySelectorAll('.mode-btn').forEach(btn => {
                btn.addEventListener('click', switchMode);
            });

            // Auto capture controls
            document.getElementById('captureInterval').addEventListener('input', updateIntervalValue);
            document.getElementById('startAutoCapture').addEventListener('click', startAutoCapture);
            document.getElementById('stopAutoCapture').addEventListener('click', stopAutoCapture);

            // File upload
            document.getElementById('uploadButton').addEventListener('click', handleFileUpload);
            document.getElementById('bulkUpload').addEventListener('click', handleBulkUpload);
            document.getElementById('enhancedProcessing').addEventListener('click', handleEnhancedProcessing);
            document.getElementById('extractWithLanguage').addEventListener('click', extractWithLanguage);

            // Text controls
            extractedTextArea.addEventListener('input', updateTextStats);
            document.getElementById('clearText').addEventListener('click', clearText);
            document.getElementById('copyText').addEventListener('click', copyText);

            // Save buttons
            document.getElementById('saveTxt').addEventListener('click', () => saveText('txt'));
            document.getElementById('saveWord').addEventListener('click', () => saveText('docx'));
            document.getElementById('savePdf').addEventListener('click', () => saveText('pdf'));

            // Enhancement controls
            document.getElementById('brightness').addEventListener('input', updateEnhancementPreview);
            document.getElementById('contrast').addEventListener('input', updateEnhancementPreview);

            // Analysis controls
            document.getElementById('checkReadability').addEventListener('click', checkReadability);
            document.getElementById('processBlurred').addEventListener('click', processBlurredImage);
            document.getElementById('processCompare').addEventListener('click', processAndCompare);

            // Tabs
            document.querySelectorAll('.tab').forEach(tab => {
                tab.addEventListener('click', switchTab);
            });

            // History controls
            document.getElementById('clearHistory').addEventListener('click', clearHistory);
        }

        // Mode switching
        function switchMode(e) {
            const mode = e.target.dataset.mode;
            document.querySelectorAll('.mode-btn').forEach(btn => {
                btn.classList.remove('active');
            });
            e.target.classList.add('active');

            isAutoMode = mode === 'auto';
            document.getElementById('autoControls').style.display = isAutoMode ? 'block' : 'none';

            if (isAutoMode && isCameraActive) {
                document.getElementById('startAutoCapture').disabled = false;
            }
        }

        // Update interval display
        function updateIntervalValue() {
            const interval = document.getElementById('captureInterval').value;
            document.getElementById('intervalValue').textContent = interval + 's';
        }

        // Camera functions
        async function toggleCamera() {
            if (isCameraActive) {
                stopCamera();
                stopAutoCapture();
            } else {
                await startCamera();
            }
        }

        async function startCamera() {
            try {
                showNotification('Starting camera...', 'warning');
                mediaStream = await navigator.mediaDevices.getUserMedia({
                    video: {
                        width: { ideal: 1280 },
                        height: { ideal: 720 },
                        facingMode: 'environment'
                    }
                });

                video.srcObject = mediaStream;
                isCameraActive = true;
                toggleCameraBtn.innerHTML = '<i class="fas fa-stop"></i> Stop Camera';
                captureBtn.disabled = false;
                discardBtn.disabled = false;

                if (isAutoMode) {
                    document.getElementById('startAutoCapture').disabled = false;
                }

                showNotification('Camera started successfully', 'success');

            } catch (error) {
                console.error("Error accessing camera: ", error);
                showNotification('Could not access camera. Please check permissions.', 'error');
            }
        }

        function stopCamera() {
            if (mediaStream) {
                mediaStream.getTracks().forEach(track => track.stop());
            }

            isCameraActive = false;
            toggleCameraBtn.innerHTML = '<i class="fas fa-play"></i> Start Camera';
            captureBtn.disabled = true;
            discardBtn.disabled = true;
            document.getElementById('startAutoCapture').disabled = true;
            document.getElementById('stopAutoCapture').disabled = true;

            // Hide captured image and show video
            capturedImage.style.display = 'none';
            video.style.display = 'block';
            imagePreviewContainer.style.display = 'none';

            showNotification('Camera stopped', 'warning');
        }

        async function captureAndProcess() {
            if (!isCameraActive) return;

            showProcessing('cameraProcessing', true);

            try {
                // Capture frame
                const context = canvas.getContext('2d');
                canvas.width = video.videoWidth;
                canvas.height = video.videoHeight;
                context.drawImage(video, 0, 0, canvas.width, canvas.height);

                // Apply enhancements
                applyEnhancements(canvas);
                const imageData = canvas.toDataURL('image/jpeg', 0.8);

                // Show captured image
                capturedImage.src = imageData;
                capturedImage.style.display = 'block';
                video.style.display = 'none';

                // Update preview
                imagePreview.src = imageData;
                imagePreviewContainer.style.display = 'block';

                // Process with OCR
                const result = await processImageWithOCR(imageData);

                // Update UI with results
                updateResults(result);

                // Update counters
                captureCount++;
                if (result.extractedText && result.extractedText.trim().length > 0) {
                    textFoundCount++;
                }
                updateCaptureCounters();

                // Add to history
                addToHistory(result, imageData);

                showNotification('Text extracted successfully!', 'success');

            } catch (error) {
                console.error("Error processing image: ", error);
                showNotification('Error processing image', 'error');
            } finally {
                showProcessing('cameraProcessing', false);
            }
        }

        function discardImage() {
            if (confirm('Are you sure you want to discard this image?')) {
                // Hide captured image and show video
                capturedImage.style.display = 'none';
                video.style.display = 'block';
                imagePreviewContainer.style.display = 'none';
                showNotification('Image discarded', 'warning');
            }
        }

        // Auto capture functions
        function startAutoCapture() {
            if (!isCameraActive || !isAutoMode) return;

            const interval = parseInt(document.getElementById('captureInterval').value) * 1000;

            document.getElementById('startAutoCapture').disabled = true;
            document.getElementById('stopAutoCapture').disabled = false;

            autoCaptureInterval = setInterval(async () => {
                if (!isCameraActive) {
                    stopAutoCapture();
                    return;
                }

                try {
                    // Capture frame
                    const context = canvas.getContext('2d');
                    canvas.width = video.videoWidth;
                    canvas.height = video.videoHeight;
                    context.drawImage(video, 0, 0, canvas.width, canvas.height);

                    // Apply enhancements
                    applyEnhancements(canvas);
                    const imageData = canvas.toDataURL('image/jpeg', 0.8);

                    // Process with OCR
                    const result = await processImageWithOCR(imageData);

                    // Update counters
                    captureCount++;
                    if (result.extractedText && result.extractedText.trim().length > 0) {
                        textFoundCount++;

                        // Update UI with results if text found
                        updateResults(result);

                        // Add to history
                        addToHistory(result, imageData);

                        showNotification(`Auto-capture found text (${captureCount})`, 'success');
                    } else {
                        showNotification(`Auto-capture #${captureCount} - No text found`, 'warning');
                    }

                    updateCaptureCounters();

                } catch (error) {
                    console.error("Error in auto capture: ", error);
                    showNotification('Error in auto capture', 'error');
                }
            }, interval);

            showNotification('Auto capture started', 'success');
        }

        function stopAutoCapture() {
            if (autoCaptureInterval) {
                clearInterval(autoCaptureInterval);
                autoCaptureInterval = null;
            }

            document.getElementById('startAutoCapture').disabled = false;
            document.getElementById('stopAutoCapture').disabled = true;

            showNotification('Auto capture stopped', 'warning');
        }

        function updateCaptureCounters() {
            document.getElementById('captureCount').textContent = captureCount;
            document.getElementById('textFoundCount').textContent = textFoundCount;
        }

        // File upload functions
        function handleFileUpload() {
            const fileInput = document.createElement('input');
            fileInput.type = 'file';
            fileInput.accept = 'image/*,.pdf,.doc,.docx';

            fileInput.onchange = async (e) => {
                const file = e.target.files[0];
                if (file) {
                    await processUploadedFile(file);
                }
            };

            fileInput.click();
        }

        async function processUploadedFile(file) {
            showProcessing('uploadProcessing', true);
            updateFileInfo(file);

            try {
                const formData = new FormData();
                formData.append('file', file);

                const response = await fetch('/ImgToText/Upload', {
                    method: 'POST',
                    body: formData
                });

                const result = await response.json();

                if (!response.ok) {
                    throw new Error(result.error || `HTTP error! status: ${response.status}`);
                }

                if (!result.success) {
                    throw new Error(result.error || 'Processing failed');
                }

                // Update preview
                const imageData = await readFileAsDataURL(file);
                imagePreview.src = imageData;
                imagePreviewContainer.style.display = 'block';

                // Store current image path for further processing
                currentImagePath = result.processedImagePath;

                // Update results
                updateResults(result);

                showNotification('File processed successfully!', 'success');

            } catch (error) {
                console.error('File Processing Error:', error);
                showNotification('Error processing file: ' + error.message, 'error');
            } finally {
                showProcessing('uploadProcessing', false);
            }
        }

        async function handleEnhancedProcessing() {
            const fileInput = document.createElement('input');
            fileInput.type = 'file';
            fileInput.accept = 'image/*,.pdf,.doc,.docx';

            fileInput.onchange = async (e) => {
                const file = e.target.files[0];
                if (file) {
                    await processEnhancedFile(file);
                }
            };

            fileInput.click();
        }

        async function processEnhancedFile(file) {
            showProcessing('uploadProcessing', true);
            updateFileInfo(file);

            try {
                const formData = new FormData();
                formData.append('file', file);

                const response = await fetch('/ImgToText/UploadEnhanced', {
                    method: 'POST',
                    body: formData
                });

                const result = await response.json();

                if (!response.ok) {
                    throw new Error(result.error || `HTTP error! status: ${response.status}`);
                }

                if (!result.success) {
                    throw new Error(result.error || 'Enhanced processing failed');
                }

                // Update preview
                const imageData = await readFileAsDataURL(file);
                imagePreview.src = imageData;
                imagePreviewContainer.style.display = 'block';

                // Update results
                updateResults(result);

                showNotification('Enhanced processing completed!', 'success');

            } catch (error) {
                console.error('Enhanced Processing Error:', error);
                showNotification('Error in enhanced processing: ' + error.message, 'error');
            } finally {
                showProcessing('uploadProcessing', false);
            }
        }

        async function handleBulkUpload() {
            const fileInput = document.createElement('input');
            fileInput.type = 'file';
            fileInput.accept = 'image/*,.pdf,.doc,.docx';
            fileInput.multiple = true;

            fileInput.onchange = async (e) => {
                const files = Array.from(e.target.files);
                if (files.length > 0) {
                    if (files.length > 20) {
                        showNotification('Maximum 20 files allowed per batch', 'error');
                        return;
                    }

                    showNotification(`Processing ${files.length} files...`, 'warning');

                    try {
                        const formData = new FormData();
                        files.forEach(file => formData.append('files', file));

                        const response = await fetch('/ImgToText/BulkProcess', {
                            method: 'POST',
                            body: formData
                        });

                        const result = await response.json();

                        if (!response.ok || !result.success) {
                            throw new Error(result.error || 'Bulk processing failed');
                        }

                        // Process results
                        let successCount = 0;
                        let allText = '';

                        result.results.forEach((fileResult, index) => {
                            if (fileResult.success && fileResult.text && fileResult.text.trim().length > 0) {
                                successCount++;

                                // Add separator between multiple texts
                                const separator = '\n\n' + '='.repeat(50) + '\n';
                                const fileHeader = `File: ${fileResult.fileName}\nConfidence: ${Math.round(fileResult.confidence)}%\n${separator}`;
                                allText += fileHeader + fileResult.text + separator;
                            }
                        });

                        // Update text area with all results
                        extractedTextArea.value = allText;
                        updateTextStats();

                        showNotification(`Bulk processing complete: ${successCount}/${files.length} files contained text`, 'success');

                    } catch (error) {
                        console.error('Bulk upload error:', error);
                        showNotification(`Bulk processing failed: ${error.message}`, 'error');
                    }
                }
            };

            fileInput.click();
        }

        // Language functions
        async function extractWithLanguage() {
            if (!currentImagePath) {
                showNotification('Please process an image first', 'error');
                return;
            }

            const language = document.getElementById('languageSelect').value;

            try {
                const response = await fetch('/ImgToText/ExtractTextWithLanguage', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        imagePath: currentImagePath,
                        language: language
                    })
                });

                const result = await response.json();

                if (!response.ok) {
                    throw new Error(result.error || `HTTP error! status: ${response.status}`);
                }

                if (result.success && result.text) {
                    extractedTextArea.value = result.text;
                    updateTextStats();
                    showNotification(`Text extracted with ${language.toUpperCase()} language model`, 'success');
                } else {
                    showNotification('No text found with selected language', 'warning');
                }

            } catch (error) {
                console.error('Language extraction error:', error);
                showNotification('Error in language extraction: ' + error.message, 'error');
            }
        }

        // Analysis functions
        async function checkReadability() {
            if (!currentImagePath) {
                showNotification('Please process an image first', 'error');
                return;
            }

            try {
                const response = await fetch('/ImgToText/CheckImageReadability', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        imagePath: currentImagePath
                    })
                });

                const result = await response.json();

                if (!response.ok) {
                    throw new Error(result.error || `HTTP error! status: ${response.status}`);
                }

                const analysisResults = document.getElementById('analysisResults');
                analysisResults.innerHTML = `
                    <strong>Readability Analysis:</strong><br>
                    - Is Readable: ${result.isReadable ? 'Yes' : 'No'}<br>
                    - Confidence: ${Math.round(result.confidence)}%<br>
                    - Text Sample: ${result.textSample || 'None'}
                `;
                analysisResults.style.display = 'block';

                showNotification('Readability check completed', 'success');

            } catch (error) {
                console.error('Readability check error:', error);
                showNotification('Error in readability check: ' + error.message, 'error');
            }
        }

        async function processBlurredImage() {
            if (!currentImagePath) {
                showNotification('Please process an image first', 'error');
                return;
            }

            try {
                const response = await fetch('/ImgToText/ProcessBlurredImage', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        imagePath: currentImagePath
                    })
                });

                const result = await response.json();

                if (!response.ok) {
                    throw new Error(result.error || `HTTP error! status: ${response.status}`);
                }

                if (result.success) {
                    extractedTextArea.value = result.text;
                    updateTextStats();

                    const analysisResults = document.getElementById('analysisResults');
                    analysisResults.innerHTML = `
                        <strong>Blurred Image Processing:</strong><br>
                        - Text Extracted: ${result.text ? 'Yes' : 'No'}<br>
                        - Confidence: ${Math.round(result.confidence)}%<br>
                        - Is Readable: ${result.isReadable ? 'Yes' : 'No'}
                    `;
                    analysisResults.style.display = 'block';

                    showNotification('Blurred image processing completed', 'success');
                }

            } catch (error) {
                console.error('Blurred processing error:', error);
                showNotification('Error in blurred processing: ' + error.message, 'error');
            }
        }

        async function processAndCompare() {
            if (!currentImagePath) {
                showNotification('Please process an image first', 'error');
                return;
            }

            try {
                const response = await fetch('/ImgToText/ProcessAndCompare', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        imagePath: currentImagePath
                    })
                });

                const result = await response.json();

                if (!response.ok) {
                    throw new Error(result.error || `HTTP error! status: ${response.status}`);
                }

                const analysisResults = document.getElementById('analysisResults');
                analysisResults.innerHTML = `
                    <strong>OCR Method Comparison:</strong><br>
                    - Original Confidence: ${Math.round(result.originalConfidence)}%<br>
                    - Processed Confidence: ${Math.round(result.processedConfidence)}%<br>
                    - Improvement: ${Math.round(result.improvement)}%<br><br>
                    <strong>Original Text:</strong><br>${result.originalText || 'None'}<br><br>
                    <strong>Processed Text:</strong><br>${result.processedText || 'None'}
                `;
                analysisResults.style.display = 'block';

                showNotification('Method comparison completed', 'success');

            } catch (error) {
                console.error('Comparison error:', error);
                showNotification('Error in method comparison: ' + error.message, 'error');
            }
        }

        // Image enhancement
        function applyEnhancements(canvas) {
            const context = canvas.getContext('2d');
            const imageData = context.getImageData(0, 0, canvas.width, canvas.height);
            const data = imageData.data;

            const brightness = (parseInt(document.getElementById('brightness').value) - 50) * 2;
            const contrast = parseInt(document.getElementById('contrast').value) / 50;

            for (let i = 0; i < data.length; i += 4) {
                // Apply brightness
                data[i] += brightness;
                data[i + 1] += brightness;
                data[i + 2] += brightness;

                // Apply contrast
                data[i] = ((data[i] - 128) * contrast) + 128;
                data[i + 1] = ((data[i + 1] - 128) * contrast) + 128;
                data[i + 2] = ((data[i + 2] - 128) * contrast) + 128;

                // Clamp values
                data[i] = Math.max(0, Math.min(255, data[i]));
                data[i + 1] = Math.max(0, Math.min(255, data[i + 1]));
                data[i + 2] = Math.max(0, Math.min(255, data[i + 2]));
            }

            context.putImageData(imageData, 0, 0);
        }

        // Tab switching
        function switchTab(e) {
            const tabName = e.target.dataset.tab;

            document.querySelectorAll('.tab').forEach(tab => {
                tab.classList.remove('active');
            });
            e.target.classList.add('active');

            document.querySelectorAll('.tab-content').forEach(content => {
                content.classList.remove('active');
            });
            document.getElementById(tabName + 'Tab').classList.add('active');
        }

        // Text management
        function updateTextStats() {
            const text = extractedTextArea.value;
            const charCount = text.length;
            const wordCount = text.trim() ? text.trim().split(/\s+/).length : 0;
            const lineCount = text ? text.split('\n').length : 0;

            document.getElementById('charCount').textContent = charCount + ' chars';
            document.getElementById('wordCount').textContent = wordCount + ' words';
            document.getElementById('lineCount').textContent = lineCount + ' lines';
        }

        function clearText() {
            if (confirm('Are you sure you want to clear all text?')) {
                extractedTextArea.value = '';
                updateTextStats();
                showNotification('Text cleared', 'warning');
            }
        }

        async function copyText() {
            try {
                await navigator.clipboard.writeText(extractedTextArea.value);
                showNotification('Text copied to clipboard!', 'success');
            } catch (error) {
                showNotification('Failed to copy text', 'error');
            }
        }

        // Save functions
        async function saveText(format) {
            const text = extractedTextArea.value;
            if (!text.trim()) {
                showNotification('No text to save', 'error');
                return;
            }

            try {
                let endpoint;
                if (format === 'txt') {
                    endpoint = '/ImgToText/SaveTextAsTxt';
                } else if (format === 'docx') {
                    endpoint = '/ImgToText/SaveTextAsDocx';
                } else if (format === 'pdf') {
                    endpoint = '/ImgToText/SaveTextAsPdf';
                } else {
                    throw new Error('Unsupported format');
                }

                const response = await fetch(endpoint, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({ text: text })
                });

                const result = await response.json();

                if (!response.ok) {
                    throw new Error(result.error || `HTTP error! status: ${response.status}`);
                }

                if (!result.success) {
                    throw new Error(result.error || 'Saving failed');
                }

                // Download the file
                const downloadUrl = `/ImgToText/DownloadFile?fileName=${encodeURIComponent(result.filePath)}`;
                const a = document.createElement('a');
                a.href = downloadUrl;
                a.download = result.filePath;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);

                showNotification(format.toUpperCase() + ' file saved successfully!', 'success');

            } catch (error) {
                console.error('Save Error:', error);
                showNotification('Error saving ' + format.toUpperCase() + ' file: ' + error.message, 'error');
            }
        }

        // History management
        function addToHistory(result, imageData) {
            const historyItem = {
                id: Date.now(),
                timestamp: new Date().toLocaleString(),
                text: result.extractedText,
                confidence: result.confidence,
                imageData: imageData
            };

            captureHistory.unshift(historyItem);
            saveCaptureHistory();
            renderHistoryItem(historyItem);
        }

        function renderHistoryItem(item) {
            const historyItem = document.createElement('div');
            historyItem.className = 'history-item';
            historyItem.dataset.id = item.id;

            const textPreview = item.text && item.text.length > 50 ?
                item.text.substring(0, 50) + '...' :
                item.text || 'No text found';

            historyItem.innerHTML = `
                <div>
                    <div style="font-weight: 600;">${item.timestamp}</div>
                    <div class="history-text-preview">${textPreview}</div>
                </div>
                <div class="history-actions">
                    <button class="history-action-btn view-history" title="View">
                        <i class="fas fa-eye"></i>
                    </button>
                    <button class="history-action-btn use-history" title="Use Text">
                        <i class="fas fa-text-height"></i>
                    </button>
                    <button class="history-action-btn delete-history" title="Delete">
                        <i class="fas fa-trash"></i>
                    </button>
                </div>
            `;

            // Add event listeners to action buttons
            historyItem.querySelector('.view-history').addEventListener('click', () => viewHistoryItem(item));
            historyItem.querySelector('.use-history').addEventListener('click', () => useHistoryItem(item));
            historyItem.querySelector('.delete-history').addEventListener('click', () => deleteHistoryItem(item.id));

            captureHistoryContainer.prepend(historyItem);
        }

        function viewHistoryItem(item) {
            // In a compact version, we might not have a modal, so we'll just use the image preview
            imagePreview.src = item.imageData;
            imagePreviewContainer.style.display = 'block';
            showNotification('Image loaded from history', 'success');
        }

        function useHistoryItem(item) {
            extractedTextArea.value = item.text;
            updateTextStats();
            switchTab({ target: document.querySelector('[data-tab="extracted"]') });
            showNotification('Text loaded from history', 'success');
        }

        function deleteHistoryItem(id) {
            if (confirm('Are you sure you want to delete this history item?')) {
                captureHistory = captureHistory.filter(item => item.id !== id);
                saveCaptureHistory();
                document.querySelector(`.history-item[data-id="${id}"]`).remove();
                showNotification('History item deleted', 'warning');
            }
        }

        function clearHistory() {
            if (confirm('Are you sure you want to clear all history?')) {
                captureHistory = [];
                saveCaptureHistory();
                captureHistoryContainer.innerHTML = '';
                showNotification('History cleared', 'warning');
            }
        }

        function loadCaptureHistory() {
            const savedHistory = localStorage.getItem('captureHistory');
            if (savedHistory) {
                captureHistory = JSON.parse(savedHistory);
                captureHistory.forEach(item => renderHistoryItem(item));
            }
        }

        function saveCaptureHistory() {
            localStorage.setItem('captureHistory', JSON.stringify(captureHistory));
        }

        // UI updates
        function updateResults(result) {
            if (result.extractedText) {
                const separator = '\n\n' + '='.repeat(50) + '\n\n';
                const newText = result.extractedText.trim();

                if (extractedTextArea.value) {
                    extractedTextArea.value += separator + newText;
                } else {
                    extractedTextArea.value = newText;
                }

                extractedTextArea.scrollTop = extractedTextArea.scrollHeight;
            }

            // Update confidence
            if (result.confidence) {
                const confidencePercent = Math.round(result.confidence);
                document.getElementById('confidenceFill').style.width = confidencePercent + '%';
                document.getElementById('confidenceText').textContent = confidencePercent + '% confidence';
            }

            updateTextStats();
        }

        function updateFileInfo(file) {
            const fileSize = formatFileSize(file.size);
            document.getElementById('fileDetails').textContent = file.name + ' (' + fileSize + ')';
            document.getElementById('fileInfo').style.display = 'block';
        }

        function updateEnhancementPreview() {
            // Enhancement preview logic can be added here
        }

        // Utility functions
        function readFileAsDataURL(file) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onload = e => resolve(e.target.result);
                reader.onerror = reject;
                reader.readAsDataURL(file);
            });
        }

        function formatFileSize(bytes) {
            if (bytes === 0) return '0 Bytes';
            const k = 1024;
            const sizes = ['Bytes', 'KB', 'MB', 'GB'];
            const i = Math.floor(Math.log(bytes) / Math.log(k));
            return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
        }

        function showNotification(message, type) {
            const notification = document.getElementById('notification');
            notification.textContent = message;
            notification.className = 'notification ' + type;
            notification.style.display = 'block';

            setTimeout(() => {
                notification.style.display = 'none';
            }, 3000);
        }

        function showProcessing(elementId, show) {
            const element = document.getElementById(elementId);
            element.style.display = show ? 'block' : 'none';
        }

        // OCR Processing
        async function processImageWithOCR(imageData) {
            showProcessing('cameraProcessing', true);

            try {
                const formData = new FormData();
                formData.append('cameraFile', imageData);

                const response = await fetch('/ImgToText/Upload', {
                    method: 'POST',
                    body: formData
                });

                const result = await response.json();

                if (!response.ok) {
                    throw new Error(result.error || `HTTP error! status: ${response.status}`);
                }

                if (!result.success) {
                    throw new Error(result.error || 'Processing failed');
                }

                // Store current image path
                currentImagePath = result.processedImagePath;

                return {
                    extractedText: result.extractedText,
                    confidence: result.confidence || 0
                };

            } catch (error) {
                console.error('OCR Processing Error:', error);
                throw new Error(`Text extraction failed: ${error.message}`);
            } finally {
                showProcessing('cameraProcessing', false);
            }
        }
    </script>
</body>
</html>